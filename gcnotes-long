Vats import and export objects as side effects of object references being
carried in message sends and promise resolutions. When an object X is first
imported into a vat, we consider it to be REACHABLE by that vat.  Reachable
means that the vat possesses a reference to X directly: it can send a message to
X and it can pass a reference to X in a message parameter. Once the vat drops
any references to X that it might be holding, the X is no longer considered
reachable. This situation will eventually be detected by the vat's garbage
collector, at which point this loss of reachability will be reported back to the
kernel via a `dropImports` syscall. If however, during the time when X was reachable, the vat used X as a key into a weak collection, X is then considered to also be RECOGNIZABLE by the vat. 

When a reference to an object
X is first imported into a vat, we consider it to be both REACHABLE and
RECOGNIZABLE. Reachable means that the vat possesses a reference to X directly:
it can send a message to X and it can pass a reference to X in a message
parameter. Recognizable means that the vat can have a weak collection in which X is used as a keywithout necessarily 

 A vat is said
to be able to RECOGNIZE an object if the object can be used as a key in a weak
table. Note that reachability implies recognizability but not vice versa.  When
we speak of the kernel reaching or recognizing some object X that resides in a
vat, it is actually other vats associated with the kernel that are doing the
reaching or recognizing, using the kernel as their intermediary. (In other
words, if we say "the kernel can reach X", what we really mean is that one or
more other vats can reach X via the kernel, and correspondingly for
recognition.)

I am a vat:

  I export: I have X, which I am making available to the kernel

  I import: Kernel has X, which it is making available to me

  Syscalls (me -> kernel)

    dropImports -- I can no longer reach kernel's X

      ==> kernel decrements X's reach refcount
      ==> if refcount is (0, 0), kernel reaps X

    retireImports -- I can no longer recognize (nor reach) kernel's X

      ==> kernel decrements X's recognize refcount
      ==> if refcount is (0, 0), kernel reaps X

    retireExports -- I no longer have my X (which the kernel is known
      not to (any longer) reference but can still recognize)

      ==> kernel removes X from its recognition set (since it no
          longer needs to be able to recognize X which it will never
          see again)

  Deliveries (kernel -> me)

    dropExports -- Kernel can no longer reach my X

    retireExports -- Kernel can no longer recognize (nor reach) my X

    retireImports -- Kernel no longer has its X (which I am known not
      to (any longer) reference but can still recognize)

I am a remote:

  In managing object references I am vat-like, but because I am actually part of
    my kernel, I don't use syscalls to update the kernel's state but instead
    directly execute the appropriate logic that a vat would request via a
    syscall

  The arrangement of the parts is:
  my Kernel::me <<=== network ===>> my counterpart (another remote)::other kernel

  I export: Other kernel has X, which my counterpart has imported and
    told me about; I make X available to my kernel

  I import: My kernel has X, which it is making available to the other kernel
    through me; I tell my counterpart about X which it exports

  Unlike a vat, I maintain no internal state with respect to X, but simply
    manage (in collaboration with my counterpart) the relationship between my
    kernel and the other kernel with respect to X

  Deliveries (kernel -> me) are simply relayed to my counterpart, who executes
    using the corresponding syscall logic (though not with an actual syscall,
    see first comment above); because my imports are my counterpart's exports
    (and vice versa), each kind of delivery is paired with an opposite-facing
    "syscall"

      <delivery> :: <"syscall">
      dropExports :: dropImports
      retireExports :: retireImports
      retireImports :: retireExports

    Since I have no internal state of my own, executing these relayed deliveries
      simply involves translating the parameter refs into kernel space and
      invoking the corresponding syscall logic
