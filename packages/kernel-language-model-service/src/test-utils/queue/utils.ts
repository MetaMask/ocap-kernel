/**
 * Normalize an array or async iterable to an async iterable.
 *
 * @param value - The value to normalize.
 * @returns The normalized value.
 */
export const normalizeToAsyncIterable = <Type>(
  value: Type[] | AsyncIterable<Type>,
): AsyncIterable<Type> =>
  Array.isArray(value)
    ? (async function* () {
        yield* value;
      })()
    : value;

/**
 * Map an async iterable to a new async iterable.
 * The mapper receives both the value and whether it's the last item.
 *
 * @param iterable - The iterable to map.
 * @param mapper - The mapper function that receives (value, done).
 * @returns The mapped iterable.
 */
export const mapAsyncIterable = <Type, Result>(
  iterable: AsyncIterable<Type>,
  mapper: (value: Type, done: boolean) => Result,
): AsyncIterable<Result> =>
  (async function* () {
    const iterator = iterable[Symbol.asyncIterator]();
    let current = await iterator.next();

    if (current.done) {
      return;
    }

    let next = await iterator.next();
    while (!next.done) {
      yield mapper(current.value, false);
      current = next;
      next = await iterator.next();
    }

    yield mapper(current.value, true);
  })();

/**
 * Creates a queue-based language model instance.
 * This is a minimal implementation of LanguageModel that uses a queue for responses.
 *
 * @template Options - The type of options supported by the model
 * @template Response - The type of response generated by the model
 * @returns A hardened queue-based language model instance with helper methods
 */
export type StreamWithAbort<Response> = {
  stream: AsyncIterable<Response>;
  abort: () => Promise<void>;
};

/**
 * Make an async iterable abortable.
 *
 * @param iterable - The iterable to make abortable.
 * @returns A tuple containing the abortable iterable and the abort function.
 */
export const makeAbortableAsyncIterable = <Type>(
  iterable: AsyncIterable<Type>,
): StreamWithAbort<Type> => {
  let didAbort = false;
  return {
    stream: (async function* () {
      for await (const value of iterable) {
        if (didAbort) {
          break;
        }
        yield value;
      }
    })(),
    abort: async () => {
      didAbort = true;
    },
  };
};

/**
 * Make an empty stream with abort.
 *
 * @returns A stream with abort.
 */
export const makeEmptyStreamWithAbort = <
  Response,
>(): StreamWithAbort<Response> => ({
  stream: (async function* () {
    // Empty stream
  })() as AsyncIterable<Response>,
  abort: async () => {
    // No-op abort
  },
});
